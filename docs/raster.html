<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>geosardine.raster API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geosardine.raster</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L0-L327" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from dataclasses import dataclass
from math import floor
from operator import (add, iadd, imul, ipow, isub, itruediv, mul, pow, sub,
                      truediv)
from typing import (Any, Callable, Generator, Iterable, List, Optional, Tuple,
                    Union)

import numpy as np
from affine import Affine
from rasterio.crs import CRS

from geosardine._geosardine import rowcol2xy, xy2rowcol
from geosardine._utility import save_raster


class Raster(np.ndarray):
    &#34;&#34;&#34;
    Construct Raster from numpy array with spatial information.
    Support calculation between different raster
    Parameters
    ----------
    array : numpy array
        array of raster
    resolution : tuple, list, default None
        spatial resolution
    x_min : float, defaults to None
        left boundary of x-axis coordinate
    y_min : float, defaults to None
        bottom boundary of y-axis coordinate
    x_max : float, defaults to None
        right boundary of x-axis coordinate
    y_max : float, defaults to None
        upper boundary of y-axis coordinate
    epsg : int, defaults to 4326
        EPSG code of reference system

    Examples
    --------
    &gt;&gt;&gt; from geosardine import Raster
    &gt;&gt;&gt; raster = Raster(np.ones(18, dtype=np.float32).reshape(3, 3, 2), 0.4, 120, 0.7)
    &gt;&gt;&gt; print(raster)
    [[[1. 1.]
      [1. 1.]
      [1. 1.]]
     [[1. 1.]
      [1. 1.]
      [1. 1.]]
     [[1. 1.]
      [1. 1.]
      [1. 1.]]]
    Raster can be resampled like this. (0.2,0.2) is the result&#39;s spatial resolution
    &gt;&gt;&gt; resampled = raster.resample((0.2,0.2))
    &gt;&gt;&gt; print(resampled.shape, resampled.resolution)
    (6, 6, 2) (0.2, 0.2)
    Raster can be resized
    &gt;&gt;&gt; resized = raster.resize(height=16, width=16)
    &gt;&gt;&gt; print(resized.shape, resized.resolution)
    (16, 16, 2) (0.07500000000000018, 0.07500000000000001)
    &#34;&#34;&#34;
    def __init__(
        self,
        array: np.ndarray,
        resolution: Union[
            None, Tuple[float, float], List[float], Tuple[float, ...], float
        ] = None,
        x_min: Optional[float] = None,
        y_min: Optional[float] = None,
        x_max: Optional[float] = None,
        y_max: Optional[float] = None,
        epsg: int = 4326,
    ):
        if (
            resolution is None
            and x_min is None
            and y_min is None
            and x_max is None
            and y_max is None
        ):
            raise ValueError(
                &#34;Please define resolution and at least x minimum and y minimum&#34;
            )

        if resolution is not None and x_min is None and y_min is None:
            raise ValueError(&#34;Please at least define x_min and y_min&#34;)

        if isinstance(resolution, float):
            self.resolution: Tuple[float, float] = (
                resolution,
                resolution,
            )
        elif resolution is not None and isinstance(resolution, Iterable):
            self.resolution = (resolution[0], resolution[1])

        if resolution is not None and x_min is not None and y_min is not None:
            self.x_min: float = x_min
            self.y_min: float = y_min
            self.x_max: float = x_min + (self.resolution[0] * array.shape[1])
            self.y_max: float = y_min + (self.resolution[1] * array.shape[0])
        elif (
            resolution is None
            and x_min is not None
            and y_min is not None
            and x_max is not None
            and y_max is not None
        ):
            self.resolution = (
                (x_max - x_min) / array.shape[1],
                (y_max - y_min) / array.shape[0],
            )
            self.x_min = x_min
            self.y_min = y_min
            self.x_max = x_max
            self.y_max = y_max

        self.array = array
        self.epsg = epsg
        self.transform = Affine.translation(self.x_min, self.y_min) * Affine.scale(
            self.resolution[0], -self.resolution[1]
        )
        self.crs = CRS.from_epsg(epsg)

    def __new__(cls, array: np.ndarray, *args, **kwargs) -&gt; &#34;Raster&#34;:
        return array.view(cls)

    @property
    def rows(self) -&gt; int:
        &#34;&#34;&#34;[summary]

        Returns
        -------
        int
            [description]
        &#34;&#34;&#34;
        return int(self.array.shape[0])

    @property
    def cols(self) -&gt; int:
        return int(self.array.shape[1])

    @property
    def layers(self) -&gt; int:
        _layers = 1
        if len(self.array.shape) &gt; 2:
            _layers = self.array.shape[2]
        return _layers

    @property
    def x_extent(self) -&gt; float:
        return self.x_max - self.x_min

    @property
    def y_extent(self) -&gt; float:
        return self.y_max - self.y_min

    @property
    def is_projected(self) -&gt; bool:
        return self.crs.is_projected

    @property
    def is_geographic(self) -&gt; bool:
        return self.crs.is_geographic

    def xy_value(self, x: float, y: float) -&gt; Union[float, int, np.ndarray]:
        return self.array[xy2rowcol((x, y), self.transform)]

    def rowcol2xy(self, row: int, col: int) -&gt; Tuple[float, float]:
        return rowcol2xy((row, col), self.transform)

    def xy2rowcol(self, x: float, y: float) -&gt; Tuple[int, int]:
        _row, _col = xy2rowcol((x, y), self.transform)
        return int(_row), int(_col)

    def __raster_calculation__(
        self,
        raster: Union[int, float, &#34;Raster&#34;],
        operator: Callable[[Any, Any], Any],
    ) -&gt; &#34;Raster&#34;:
        if not isinstance(raster, (int, float, Raster)):
            raise ValueError(f&#34;{type(raster)} unsupported data format&#34;)

        if isinstance(raster, Raster):
            _raster = np.zeros(self.array.shape, dtype=self.array.dtype)
            for row in range(self.rows):
                for col in range(self.cols):
                    _raster[row, col] = operator(
                        self.array[row, col], raster.xy_value(*self.rowcol2xy(row, col))
                    )
        else:
            _raster = operator(self.array, raster)

        return Raster(_raster, self.resolution, self.x_min, self.y_min, epsg=self.epsg)

    def __sub__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, sub)

    def __add__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, add)

    def __mul__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, mul)

    def __truediv__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, truediv)

    def __pow__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, pow)

    def __iadd__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, iadd)

    def __itruediv__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, itruediv)

    def __imul__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, imul)

    def __isub__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, isub)

    def __ipow__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, ipow)

    def __iter__(self) -&gt; Generator[Any, None, None]:
        _iter_shape: Union[Tuple[int, int], int] = (self.rows * self.cols, self.layers)
        if self.layers == 1:
            _iter_shape = self.rows * self.cols
        _iter = self.array.reshape(_iter_shape)
        for i in range(10):
            yield _iter[i]

    def save(self, file_name: str) -&gt; None:
        save_raster(file_name, self.array, self.crs, affine=self.transform)

    def resample(
        self, resolution: Union[Tuple[float, float], List[float], float]
    ) -&gt; &#34;Raster&#34;:
        &#34;&#34;&#34;
        Resample raster using nearest neighbor
        Parameters
        -------
        resolution: tuple, list
            spatial resolution target

        Returns
        -------
        Raster
            Resampled
        &#34;&#34;&#34;

        if isinstance(resolution, (float, int)):
            resampled_x_resolution = float(resolution)
            resampled_y_resolution = float(resolution)
        else:
            resampled_x_resolution = resolution[0]
            resampled_y_resolution = resolution[1]

        resampled_rows = round(self.y_extent / resampled_y_resolution)
        resampled_cols = round(self.x_extent / resampled_x_resolution)

        resampled_shape: Tuple[int, ...] = (resampled_rows, resampled_cols, self.layers)
        if self.layers == 1:
            resampled_shape = (resampled_rows, resampled_cols)

        resampled_array = np.zeros(
            resampled_rows * resampled_cols * self.layers, dtype=self.dtype
        ).reshape(resampled_shape)

        resampled_affine = Affine.translation(self.x_min, self.y_min) * Affine.scale(
            resampled_x_resolution, -resampled_y_resolution
        )

        for row in range(resampled_rows):
            for col in range(resampled_cols):
                x, y = rowcol2xy((row, col), resampled_affine)
                resampled_array[row, col] = self.xy_value(
                    x + (resampled_x_resolution / 2), y + (resampled_y_resolution / 2)
                )

        return Raster(
            resampled_array,
            (resampled_x_resolution, resampled_y_resolution),
            self.x_min,
            self.y_min,
        )

    def resize(self, height: int, width: int) -&gt; &#34;Raster&#34;:
        &#34;&#34;&#34;
        Resize raster using nearest neighbor
        Parameters
        -------
        height: int
            raster height
        width: int
            raster width

        Returns
        -------
        Raster
            Resampled
        &#34;&#34;&#34;
        resized_y_resolution = self.y_extent / height
        resized_x_resolution = self.x_extent / width

        resized_affine = Affine.translation(self.x_min, self.y_min) * Affine.scale(
            resized_x_resolution, -resized_y_resolution
        )

        resized_shape: Tuple[int, ...] = (height, width, self.layers)
        if self.layers == 1:
            resized_shape = (height, width)

        resized_array = np.zeros(
            height * width * self.layers, dtype=self.dtype
        ).reshape(resized_shape)

        for row in range(height):
            for col in range(width):
                x, y = rowcol2xy((row, col), resized_affine)
                resized_array[row, col] = self.xy_value(
                    x + (resized_x_resolution / 2), y + (resized_y_resolution / 2)
                )

        return Raster(
            resized_array,
            (resized_x_resolution, resized_y_resolution),
            self.x_min,
            self.y_min,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geosardine.raster.Raster"><code class="flex name class">
<span>class <span class="ident">Raster</span></span>
<span>(</span><span>array:Â numpy.ndarray, resolution:Â Union[NoneType,Â Tuple[float,Â float],Â List[float],Â Tuple[float,Â ...],Â float]Â =Â None, x_min:Â Union[float,Â NoneType]Â =Â None, y_min:Â Union[float,Â NoneType]Â =Â None, x_max:Â Union[float,Â NoneType]Â =Â None, y_max:Â Union[float,Â NoneType]Â =Â None, epsg:Â intÂ =Â 4326)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct Raster from numpy array with spatial information.
Support calculation between different raster
Parameters</p>
<hr>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>array of raster</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>tuple, list</code>, default <code>None</code></dt>
<dd>spatial resolution</dd>
<dt><strong><code>x_min</code></strong> :&ensp;<code>float, defaults to None</code></dt>
<dd>left boundary of x-axis coordinate</dd>
<dt><strong><code>y_min</code></strong> :&ensp;<code>float, defaults to None</code></dt>
<dd>bottom boundary of y-axis coordinate</dd>
<dt><strong><code>x_max</code></strong> :&ensp;<code>float, defaults to None</code></dt>
<dd>right boundary of x-axis coordinate</dd>
<dt><strong><code>y_max</code></strong> :&ensp;<code>float, defaults to None</code></dt>
<dd>upper boundary of y-axis coordinate</dd>
<dt><strong><code>epsg</code></strong> :&ensp;<code>int, defaults to 4326</code></dt>
<dd>EPSG code of reference system</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from geosardine import Raster
&gt;&gt;&gt; raster = Raster(np.ones(18, dtype=np.float32).reshape(3, 3, 2), 0.4, 120, 0.7)
&gt;&gt;&gt; print(raster)
[[[1. 1.]
  [1. 1.]
  [1. 1.]]
 [[1. 1.]
  [1. 1.]
  [1. 1.]]
 [[1. 1.]
  [1. 1.]
  [1. 1.]]]
Raster can be resampled like this. (0.2,0.2) is the result's spatial resolution
&gt;&gt;&gt; resampled = raster.resample((0.2,0.2))
&gt;&gt;&gt; print(resampled.shape, resampled.resolution)
(6, 6, 2) (0.2, 0.2)
Raster can be resized
&gt;&gt;&gt; resized = raster.resize(height=16, width=16)
&gt;&gt;&gt; print(resized.shape, resized.resolution)
(16, 16, 2) (0.07500000000000018, 0.07500000000000001)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L16-L328" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Raster(np.ndarray):
    &#34;&#34;&#34;
    Construct Raster from numpy array with spatial information.
    Support calculation between different raster
    Parameters
    ----------
    array : numpy array
        array of raster
    resolution : tuple, list, default None
        spatial resolution
    x_min : float, defaults to None
        left boundary of x-axis coordinate
    y_min : float, defaults to None
        bottom boundary of y-axis coordinate
    x_max : float, defaults to None
        right boundary of x-axis coordinate
    y_max : float, defaults to None
        upper boundary of y-axis coordinate
    epsg : int, defaults to 4326
        EPSG code of reference system

    Examples
    --------
    &gt;&gt;&gt; from geosardine import Raster
    &gt;&gt;&gt; raster = Raster(np.ones(18, dtype=np.float32).reshape(3, 3, 2), 0.4, 120, 0.7)
    &gt;&gt;&gt; print(raster)
    [[[1. 1.]
      [1. 1.]
      [1. 1.]]
     [[1. 1.]
      [1. 1.]
      [1. 1.]]
     [[1. 1.]
      [1. 1.]
      [1. 1.]]]
    Raster can be resampled like this. (0.2,0.2) is the result&#39;s spatial resolution
    &gt;&gt;&gt; resampled = raster.resample((0.2,0.2))
    &gt;&gt;&gt; print(resampled.shape, resampled.resolution)
    (6, 6, 2) (0.2, 0.2)
    Raster can be resized
    &gt;&gt;&gt; resized = raster.resize(height=16, width=16)
    &gt;&gt;&gt; print(resized.shape, resized.resolution)
    (16, 16, 2) (0.07500000000000018, 0.07500000000000001)
    &#34;&#34;&#34;
    def __init__(
        self,
        array: np.ndarray,
        resolution: Union[
            None, Tuple[float, float], List[float], Tuple[float, ...], float
        ] = None,
        x_min: Optional[float] = None,
        y_min: Optional[float] = None,
        x_max: Optional[float] = None,
        y_max: Optional[float] = None,
        epsg: int = 4326,
    ):
        if (
            resolution is None
            and x_min is None
            and y_min is None
            and x_max is None
            and y_max is None
        ):
            raise ValueError(
                &#34;Please define resolution and at least x minimum and y minimum&#34;
            )

        if resolution is not None and x_min is None and y_min is None:
            raise ValueError(&#34;Please at least define x_min and y_min&#34;)

        if isinstance(resolution, float):
            self.resolution: Tuple[float, float] = (
                resolution,
                resolution,
            )
        elif resolution is not None and isinstance(resolution, Iterable):
            self.resolution = (resolution[0], resolution[1])

        if resolution is not None and x_min is not None and y_min is not None:
            self.x_min: float = x_min
            self.y_min: float = y_min
            self.x_max: float = x_min + (self.resolution[0] * array.shape[1])
            self.y_max: float = y_min + (self.resolution[1] * array.shape[0])
        elif (
            resolution is None
            and x_min is not None
            and y_min is not None
            and x_max is not None
            and y_max is not None
        ):
            self.resolution = (
                (x_max - x_min) / array.shape[1],
                (y_max - y_min) / array.shape[0],
            )
            self.x_min = x_min
            self.y_min = y_min
            self.x_max = x_max
            self.y_max = y_max

        self.array = array
        self.epsg = epsg
        self.transform = Affine.translation(self.x_min, self.y_min) * Affine.scale(
            self.resolution[0], -self.resolution[1]
        )
        self.crs = CRS.from_epsg(epsg)

    def __new__(cls, array: np.ndarray, *args, **kwargs) -&gt; &#34;Raster&#34;:
        return array.view(cls)

    @property
    def rows(self) -&gt; int:
        &#34;&#34;&#34;[summary]

        Returns
        -------
        int
            [description]
        &#34;&#34;&#34;
        return int(self.array.shape[0])

    @property
    def cols(self) -&gt; int:
        return int(self.array.shape[1])

    @property
    def layers(self) -&gt; int:
        _layers = 1
        if len(self.array.shape) &gt; 2:
            _layers = self.array.shape[2]
        return _layers

    @property
    def x_extent(self) -&gt; float:
        return self.x_max - self.x_min

    @property
    def y_extent(self) -&gt; float:
        return self.y_max - self.y_min

    @property
    def is_projected(self) -&gt; bool:
        return self.crs.is_projected

    @property
    def is_geographic(self) -&gt; bool:
        return self.crs.is_geographic

    def xy_value(self, x: float, y: float) -&gt; Union[float, int, np.ndarray]:
        return self.array[xy2rowcol((x, y), self.transform)]

    def rowcol2xy(self, row: int, col: int) -&gt; Tuple[float, float]:
        return rowcol2xy((row, col), self.transform)

    def xy2rowcol(self, x: float, y: float) -&gt; Tuple[int, int]:
        _row, _col = xy2rowcol((x, y), self.transform)
        return int(_row), int(_col)

    def __raster_calculation__(
        self,
        raster: Union[int, float, &#34;Raster&#34;],
        operator: Callable[[Any, Any], Any],
    ) -&gt; &#34;Raster&#34;:
        if not isinstance(raster, (int, float, Raster)):
            raise ValueError(f&#34;{type(raster)} unsupported data format&#34;)

        if isinstance(raster, Raster):
            _raster = np.zeros(self.array.shape, dtype=self.array.dtype)
            for row in range(self.rows):
                for col in range(self.cols):
                    _raster[row, col] = operator(
                        self.array[row, col], raster.xy_value(*self.rowcol2xy(row, col))
                    )
        else:
            _raster = operator(self.array, raster)

        return Raster(_raster, self.resolution, self.x_min, self.y_min, epsg=self.epsg)

    def __sub__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, sub)

    def __add__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, add)

    def __mul__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, mul)

    def __truediv__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, truediv)

    def __pow__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, pow)

    def __iadd__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, iadd)

    def __itruediv__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, itruediv)

    def __imul__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, imul)

    def __isub__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, isub)

    def __ipow__(self, raster: Union[int, float, &#34;Raster&#34;]) -&gt; &#34;Raster&#34;:
        return self.__raster_calculation__(raster, ipow)

    def __iter__(self) -&gt; Generator[Any, None, None]:
        _iter_shape: Union[Tuple[int, int], int] = (self.rows * self.cols, self.layers)
        if self.layers == 1:
            _iter_shape = self.rows * self.cols
        _iter = self.array.reshape(_iter_shape)
        for i in range(10):
            yield _iter[i]

    def save(self, file_name: str) -&gt; None:
        save_raster(file_name, self.array, self.crs, affine=self.transform)

    def resample(
        self, resolution: Union[Tuple[float, float], List[float], float]
    ) -&gt; &#34;Raster&#34;:
        &#34;&#34;&#34;
        Resample raster using nearest neighbor
        Parameters
        -------
        resolution: tuple, list
            spatial resolution target

        Returns
        -------
        Raster
            Resampled
        &#34;&#34;&#34;

        if isinstance(resolution, (float, int)):
            resampled_x_resolution = float(resolution)
            resampled_y_resolution = float(resolution)
        else:
            resampled_x_resolution = resolution[0]
            resampled_y_resolution = resolution[1]

        resampled_rows = round(self.y_extent / resampled_y_resolution)
        resampled_cols = round(self.x_extent / resampled_x_resolution)

        resampled_shape: Tuple[int, ...] = (resampled_rows, resampled_cols, self.layers)
        if self.layers == 1:
            resampled_shape = (resampled_rows, resampled_cols)

        resampled_array = np.zeros(
            resampled_rows * resampled_cols * self.layers, dtype=self.dtype
        ).reshape(resampled_shape)

        resampled_affine = Affine.translation(self.x_min, self.y_min) * Affine.scale(
            resampled_x_resolution, -resampled_y_resolution
        )

        for row in range(resampled_rows):
            for col in range(resampled_cols):
                x, y = rowcol2xy((row, col), resampled_affine)
                resampled_array[row, col] = self.xy_value(
                    x + (resampled_x_resolution / 2), y + (resampled_y_resolution / 2)
                )

        return Raster(
            resampled_array,
            (resampled_x_resolution, resampled_y_resolution),
            self.x_min,
            self.y_min,
        )

    def resize(self, height: int, width: int) -&gt; &#34;Raster&#34;:
        &#34;&#34;&#34;
        Resize raster using nearest neighbor
        Parameters
        -------
        height: int
            raster height
        width: int
            raster width

        Returns
        -------
        Raster
            Resampled
        &#34;&#34;&#34;
        resized_y_resolution = self.y_extent / height
        resized_x_resolution = self.x_extent / width

        resized_affine = Affine.translation(self.x_min, self.y_min) * Affine.scale(
            resized_x_resolution, -resized_y_resolution
        )

        resized_shape: Tuple[int, ...] = (height, width, self.layers)
        if self.layers == 1:
            resized_shape = (height, width)

        resized_array = np.zeros(
            height * width * self.layers, dtype=self.dtype
        ).reshape(resized_shape)

        for row in range(height):
            for col in range(width):
                x, y = rowcol2xy((row, col), resized_affine)
                resized_array[row, col] = self.xy_value(
                    x + (resized_x_resolution / 2), y + (resized_y_resolution / 2)
                )

        return Raster(
            resized_array,
            (resized_x_resolution, resized_y_resolution),
            self.x_min,
            self.y_min,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>numpy.ndarray</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="geosardine.raster.Raster.cols"><code class="name">var <span class="ident">cols</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L136-L138" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def cols(self) -&gt; int:
    return int(self.array.shape[1])</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.is_geographic"><code class="name">var <span class="ident">is_geographic</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L159-L161" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_geographic(self) -&gt; bool:
    return self.crs.is_geographic</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.is_projected"><code class="name">var <span class="ident">is_projected</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L155-L157" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_projected(self) -&gt; bool:
    return self.crs.is_projected</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.layers"><code class="name">var <span class="ident">layers</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L140-L145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def layers(self) -&gt; int:
    _layers = 1
    if len(self.array.shape) &gt; 2:
        _layers = self.array.shape[2]
    return _layers</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.rows"><code class="name">var <span class="ident">rows</span> :Â int</code></dt>
<dd>
<div class="desc"><p>[summary]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L125-L134" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def rows(self) -&gt; int:
    &#34;&#34;&#34;[summary]

    Returns
    -------
    int
        [description]
    &#34;&#34;&#34;
    return int(self.array.shape[0])</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.x_extent"><code class="name">var <span class="ident">x_extent</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L147-L149" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def x_extent(self) -&gt; float:
    return self.x_max - self.x_min</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.y_extent"><code class="name">var <span class="ident">y_extent</span> :Â float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L151-L153" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def y_extent(self) -&gt; float:
    return self.y_max - self.y_min</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geosardine.raster.Raster.resample"><code class="name flex">
<span>def <span class="ident">resample</span></span>(<span>self, resolution:Â Union[Tuple[float,Â float],Â List[float],Â float]) â€‘>Â <a title="geosardine.raster.Raster" href="#geosardine.raster.Raster">Raster</a></span>
</code></dt>
<dd>
<div class="desc"><p>Resample raster using nearest neighbor
Parameters</p>
<hr>
<dl>
<dt><strong><code>resolution</code></strong> :&ensp;<code>tuple, list</code></dt>
<dd>spatial resolution target</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geosardine.raster.Raster" href="#geosardine.raster.Raster">Raster</a></code></dt>
<dd>Resampled</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L234-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resample(
    self, resolution: Union[Tuple[float, float], List[float], float]
) -&gt; &#34;Raster&#34;:
    &#34;&#34;&#34;
    Resample raster using nearest neighbor
    Parameters
    -------
    resolution: tuple, list
        spatial resolution target

    Returns
    -------
    Raster
        Resampled
    &#34;&#34;&#34;

    if isinstance(resolution, (float, int)):
        resampled_x_resolution = float(resolution)
        resampled_y_resolution = float(resolution)
    else:
        resampled_x_resolution = resolution[0]
        resampled_y_resolution = resolution[1]

    resampled_rows = round(self.y_extent / resampled_y_resolution)
    resampled_cols = round(self.x_extent / resampled_x_resolution)

    resampled_shape: Tuple[int, ...] = (resampled_rows, resampled_cols, self.layers)
    if self.layers == 1:
        resampled_shape = (resampled_rows, resampled_cols)

    resampled_array = np.zeros(
        resampled_rows * resampled_cols * self.layers, dtype=self.dtype
    ).reshape(resampled_shape)

    resampled_affine = Affine.translation(self.x_min, self.y_min) * Affine.scale(
        resampled_x_resolution, -resampled_y_resolution
    )

    for row in range(resampled_rows):
        for col in range(resampled_cols):
            x, y = rowcol2xy((row, col), resampled_affine)
            resampled_array[row, col] = self.xy_value(
                x + (resampled_x_resolution / 2), y + (resampled_y_resolution / 2)
            )

    return Raster(
        resampled_array,
        (resampled_x_resolution, resampled_y_resolution),
        self.x_min,
        self.y_min,
    )</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, height:Â int, width:Â int) â€‘>Â <a title="geosardine.raster.Raster" href="#geosardine.raster.Raster">Raster</a></span>
</code></dt>
<dd>
<div class="desc"><p>Resize raster using nearest neighbor
Parameters</p>
<hr>
<dl>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code></dt>
<dd>raster height</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code></dt>
<dd>raster width</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="geosardine.raster.Raster" href="#geosardine.raster.Raster">Raster</a></code></dt>
<dd>Resampled</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L286-L328" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resize(self, height: int, width: int) -&gt; &#34;Raster&#34;:
    &#34;&#34;&#34;
    Resize raster using nearest neighbor
    Parameters
    -------
    height: int
        raster height
    width: int
        raster width

    Returns
    -------
    Raster
        Resampled
    &#34;&#34;&#34;
    resized_y_resolution = self.y_extent / height
    resized_x_resolution = self.x_extent / width

    resized_affine = Affine.translation(self.x_min, self.y_min) * Affine.scale(
        resized_x_resolution, -resized_y_resolution
    )

    resized_shape: Tuple[int, ...] = (height, width, self.layers)
    if self.layers == 1:
        resized_shape = (height, width)

    resized_array = np.zeros(
        height * width * self.layers, dtype=self.dtype
    ).reshape(resized_shape)

    for row in range(height):
        for col in range(width):
            x, y = rowcol2xy((row, col), resized_affine)
            resized_array[row, col] = self.xy_value(
                x + (resized_x_resolution / 2), y + (resized_y_resolution / 2)
            )

    return Raster(
        resized_array,
        (resized_x_resolution, resized_y_resolution),
        self.x_min,
        self.y_min,
    )</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.rowcol2xy"><code class="name flex">
<span>def <span class="ident">rowcol2xy</span></span>(<span>self, row:Â int, col:Â int) â€‘>Â Tuple[float,Â float]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L166-L167" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rowcol2xy(self, row: int, col: int) -&gt; Tuple[float, float]:
    return rowcol2xy((row, col), self.transform)</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, file_name:Â str) â€‘>Â NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L231-L232" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def save(self, file_name: str) -&gt; None:
    save_raster(file_name, self.array, self.crs, affine=self.transform)</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.xy2rowcol"><code class="name flex">
<span>def <span class="ident">xy2rowcol</span></span>(<span>self, x:Â float, y:Â float) â€‘>Â Tuple[int,Â int]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L169-L171" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xy2rowcol(self, x: float, y: float) -&gt; Tuple[int, int]:
    _row, _col = xy2rowcol((x, y), self.transform)
    return int(_row), int(_col)</code></pre>
</details>
</dd>
<dt id="geosardine.raster.Raster.xy_value"><code class="name flex">
<span>def <span class="ident">xy_value</span></span>(<span>self, x:Â float, y:Â float) â€‘>Â Union[float,Â int,Â numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/sahitono/geosardine/blob/917e96f025aa1b18afa104ce6291455ca1c42db0/geosardine\raster.py#L163-L164" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xy_value(self, x: float, y: float) -&gt; Union[float, int, np.ndarray]:
    return self.array[xy2rowcol((x, y), self.transform)]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = 'search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geosardine" href="index.html">geosardine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geosardine.raster.Raster" href="#geosardine.raster.Raster">Raster</a></code></h4>
<ul class="two-column">
<li><code><a title="geosardine.raster.Raster.cols" href="#geosardine.raster.Raster.cols">cols</a></code></li>
<li><code><a title="geosardine.raster.Raster.is_geographic" href="#geosardine.raster.Raster.is_geographic">is_geographic</a></code></li>
<li><code><a title="geosardine.raster.Raster.is_projected" href="#geosardine.raster.Raster.is_projected">is_projected</a></code></li>
<li><code><a title="geosardine.raster.Raster.layers" href="#geosardine.raster.Raster.layers">layers</a></code></li>
<li><code><a title="geosardine.raster.Raster.resample" href="#geosardine.raster.Raster.resample">resample</a></code></li>
<li><code><a title="geosardine.raster.Raster.resize" href="#geosardine.raster.Raster.resize">resize</a></code></li>
<li><code><a title="geosardine.raster.Raster.rowcol2xy" href="#geosardine.raster.Raster.rowcol2xy">rowcol2xy</a></code></li>
<li><code><a title="geosardine.raster.Raster.rows" href="#geosardine.raster.Raster.rows">rows</a></code></li>
<li><code><a title="geosardine.raster.Raster.save" href="#geosardine.raster.Raster.save">save</a></code></li>
<li><code><a title="geosardine.raster.Raster.x_extent" href="#geosardine.raster.Raster.x_extent">x_extent</a></code></li>
<li><code><a title="geosardine.raster.Raster.xy2rowcol" href="#geosardine.raster.Raster.xy2rowcol">xy2rowcol</a></code></li>
<li><code><a title="geosardine.raster.Raster.xy_value" href="#geosardine.raster.Raster.xy_value">xy_value</a></code></li>
<li><code><a title="geosardine.raster.Raster.y_extent" href="#geosardine.raster.Raster.y_extent">y_extent</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>